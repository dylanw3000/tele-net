<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sEnemy</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>oEnemy</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
event_inherited();

xx = room_width/2;
yy = room_height/2;

init_time = 1;
init_timer = 0;

hp_max = 2000;
hp = hp_max;
push1 = hp_max*.6;

swirl_in = 350;
swirl_out = 250;

pillar_dist = 240;
pillar_w = 50;
pillar_exp_w = 180;
pillar_ang = 0;
pillar_ang_mod = .3;

laser_l = 220;
laser_w = 40;
laser_ang = 0;
laser_ang_mod = -.6;
laser_dam_time = .2;
laser_dam_timer = 0;
laser_damage = 300;

explo_cd = 8;
explo_timer = explo_cd-1;
explo_delay = 4;
explo_out = 550;
explo_dam = 600;

pillars = ds_list_create();
for(j=0; j&lt;4; j++){
    ang = pi/2*j+pi/4;
    pillar = instance_create(x+cos(ang)*pillar_dist, y+sin(ang)*pillar_dist, oPillar)
    pillar.width = pillar_w;
    ds_list_add(pillars, pillar);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
for(i=0; i&lt;ds_list_size(pillars); i++){
    pillar = ds_list_find_value(pillars, i);
    ang = pi/2*i+pi/4+pillar_ang;
    //pillar.x += 5*d_time;
    pillar.x = x+cos(ang)*pillar_dist;
    pillar.y = y+sin(ang)*pillar_dist;
}

if(init_timer &lt; init_time){
    scale = 1;
    if(init_timer &lt; init_time/3){
        scale = init_timer*3/init_time;
    }
    
    for(i=0; i&lt;4; i++){
        ang = pi/2*i+pi/4;
        
        pillar = ds_list_find_value(pillars, i);
        
        tele_circ(pillar.x,pillar.y, 0,pillar_exp_w, -pi,pi, 0, init_timer/init_time*pillar_exp_w);
        //tele_circ(x+cos(ang)*pillar_dist,y+sin(ang)*pillar_dist, 0,pillar_exp_w, -pi,pi, 0, init_timer/init_time*pillar_exp_w);
        
        fill = laser_l*init_timer/init_time;
        
        for(j=0; j&lt;4; j++){
            tele_rect(
                pillar.x,
                pillar.y, 
                laser_l*scale,
                laser_w*scale, 
                laser_ang+pi/2*j+pi/4*(i%2), 
                0, 
                fill
            );
        }
        
    }
    
    tele_circ(x,y, swirl_in+swirl_out*(1-scale),swirl_in+swirl_out, -pi,pi, 0, (init_time-init_timer)/init_time*swirl_out+swirl_in);
    
    init_timer += d_time;
}
else{
    if(hp &gt; push1){
        tele_circ(x,y, swirl_in+swirl_out*(1-scale),swirl_in+swirl_out, -pi,pi, 0, 0);
        
        laser_ang += laser_ang_mod*d_time;
        laser_dam_timer += d_time;
        
        if(laser_dam_timer &gt;= laser_dam_time){
            player = instance_find(oPlayer,0);
        }
        
        for(i=0; i&lt;4; i++){
            ang = pi/2*i+pi/4;
            pillar = ds_list_find_value(pillars, i);
            //tele_circ(x+cos(ang)*pillar_dist,y+sin(ang)*pillar_dist, 0,pillar_w, -pi,pi, 0, 0);
            
            for(j=0; j&lt;4; j++){
                tele_rect(
                    pillar.x,
                    pillar.y, 
                    laser_l,
                    laser_w, 
                    laser_ang+pi/2*j+pi/4*(i%2), 
                    0, 
                    laser_l
                );
                if(laser_dam_timer &gt;= laser_dam_time){
                    for(pno=0; pno&lt;ds_list_size(local_players); pno++){
                        unit = ds_list_find_value(local_players, pno);
                        collide_rect(
                            pillar.x,
                            pillar.y, 
                            laser_l,
                            laser_w, 
                            laser_ang+pi/2*j+pi/4*(i%2), 
                            laser_damage, 
                            unit
                        );
                    }
                }
            }
        }
        if(laser_dam_timer &gt;= laser_dam_time){
            laser_dam_timer -= laser_dam_time;
        }
    }
    else if(true){
        pillar_ang += pillar_ang_mod*d_time;
        
        for(i=0; i&lt;ds_list_size(pillars); i++){
            pillar = ds_list_find_value(pillars, i);
            ang = pi/2*i+pi/4+pillar_ang;
            //pillar.x += 5*d_time;
            pillar.x = x+cos(ang)*pillar_dist;
            pillar.y = y+sin(ang)*pillar_dist;
        }
        
        explo_timer += d_time;
        if(explo_timer &gt;= explo_cd){
            fill = explo_out*(explo_timer-explo_cd)/explo_delay;
            tele_circ(x,y, 0,pillar_dist, -pi,pi, 0,fill);
            
            unit = instance_find(oPlayer,0);
            
            for(j=0; j&lt;ds_list_size(pillars); j++){
                pillar = ds_list_find_value(pillars, j);
                ang = arctan2(pillar.y-y,pillar.x-x);
                ang1 = arctan2(pillar.y+sin(ang+pi/2)*pillar_w-y,
                    pillar.x+cos(ang+pi/2)*pillar_w-x);
                
                if(j+1 &gt;= ds_list_size(pillars)){
                    pillar = ds_list_find_value(pillars, 0);
                }
                else{
                    pillar = ds_list_find_value(pillars, j+1);
                }
                ang = arctan2(pillar.y-y,pillar.x-x);
                ang2 = arctan2(pillar.y-sin(ang+pi/2)*pillar_w-y,
                    pillar.x-cos(ang+pi/2)*pillar_w-x);
                
                if(ang1 &gt; ang2){
                    ang1 -= 2*pi;
                }
                
                tele_circ(x,y, pillar_dist,explo_out, ang1,ang2, 0,fill);
                if(explo_timer &gt;= explo_cd+explo_delay){
                    collide_circ(x,y, pillar_dist,explo_out, ang1,ang2, explo_dam, unit);
                }
            }
            
            if(explo_timer &gt;= explo_cd+explo_delay){
                explo_timer -= explo_cd+explo_delay;
                collide_circ(x,y, 0,pillar_dist, -pi,pi, explo_dam, unit);
            }
        }
    }
}

//draw_self();
event_inherited();

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
